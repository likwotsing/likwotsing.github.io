(window.webpackJsonp=window.webpackJsonp||[]).push([[14],{201:function(t,e,s){"use strict";s.r(e);var r=s(0),a=Object(r.a)({},function(){var t=this,e=t.$createElement,s=t._self._c||e;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"betterscroll-的“疑难杂症”"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#betterscroll-的“疑难杂症”","aria-hidden":"true"}},[t._v("#")]),t._v(" BetterScroll 的“疑难杂症”")]),t._v(" "),s("h2",{attrs:{id:"【问题一】为什么我的-betterscroll-滑动不了？"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#【问题一】为什么我的-betterscroll-滑动不了？","aria-hidden":"true"}},[t._v("#")]),t._v(" 【问题一】为什么我的 BetterScroll 滑动不了？")]),t._v(" "),s("p",[t._v("问题基本上出在于高度的计算错误。首先，你必须对 BetterScroll 的滚动原理有一个清晰的认识，对于竖向滚动，简单的来说就是 wrapper 容器的高度大于 content 内容的高度，修改 translateY 来达到滚动的目的，横向滚动的原理类似。那么计算可滚动的高度就是 BetterScroll 必备的逻辑。一般这个逻辑出错的场景在于：")]),t._v(" "),s("ol",[s("li",[t._v("存在不确定尺寸的图片\n"),s("ul",[s("li",[t._v("原因\nbs 执行计算可滚动高度的时候，图片还未渲染完成，也无法监听到图片的加载。有时候甚至配置 observeDOM 为 true 也没效果。")]),t._v(" "),s("li",[t._v("解决\n在图片的 onload 的回调函数里面调用 bs.refresh() 来确保得到正确的图片高度之后再计算"),s("strong",[t._v("可滚动的高度")]),t._v("。")])])])]),t._v(" "),s("div",{staticClass:"tip custom-block"},[s("p",{staticClass:"custom-block-title"},[t._v("提示")]),t._v(" "),s("p",[t._v("observeDOM 为 true 的时候，BetterScroll 首先通过 MutationObserver 来监视对 DOM Tree 的改变，但是无法监听图片是否加载完成，所以需要手动调用 refresh() 来计算高度。")]),t._v(" "),s("p",[t._v("如果当前浏览器不支持 MutationObserver，会降级用 setTimeout 每隔 1s 来重复计算可滚动的高度，这样又能保证在图片加载完成之后，可滚动的高度计算正确。")])]),t._v(" "),s("ol",{attrs:{start:"2"}},[s("li",[s("p",[t._v("Vue 的 keep-alive 组件")]),t._v(" "),s("ul",[s("li",[t._v("场景")])]),t._v(" "),s("p",[t._v("假设存在 A、B 两个被 keep-alive 包裹的组件，A 组件使用了 BetterScroll，在 A 组件做了某种操作，弹出输入键盘，之后进入到 B 组件，再返回 A 组件的时候，bs 无法滚动。")]),t._v(" "),s("ul",[s("li",[t._v("原因")])]),t._v(" "),s("p",[t._v("由于 Vue 的 keep-alive 的缓存加上输入键盘弹起时候，会压缩可视区域的高度，导致之前计算过的可滚动的高度有误。")]),t._v(" "),s("ul",[s("li",[t._v("解决")])]),t._v(" "),s("p",[t._v("可以在 Vue 的 activated 的钩子里面调用 bs.refresh() 重新计算高度或者重新实例化 bs。")])])]),t._v(" "),s("h2",{attrs:{id:"【问题二】为什么我用-betterscroll-做了横向滚动之后，纵向滚动失效？"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#【问题二】为什么我用-betterscroll-做了横向滚动之后，纵向滚动失效？","aria-hidden":"true"}},[t._v("#")]),t._v(" 【问题二】为什么我用 BetterScroll 做了横向滚动之后，纵向滚动失效？")]),t._v(" "),s("p",[t._v("BetterScroll 提供了 slide 的 feature。如果实现了一个横向滚动的 slide，在 slide 区域做竖向滚动的操作，无法冒泡到浏览器，这样就无法操纵原生浏览器的滚动条了。")]),t._v(" "),s("ul",[s("li",[t._v("原因")])]),t._v(" "),s("p",[t._v("BetterScroll 内部的滚动计算存在于用户的交互，比如移动端就是 touchstart/touchmove/touchend 事件，这些事件的侦听器一般都有 e.preventDefault() 这一行代码，会阻止浏览器的默认行为，这样浏览器的滚动条无法被滚动。")]),t._v(" "),s("ul",[s("li",[t._v("解决")])]),t._v(" "),s("p",[t._v("配置 eventPassthrough 属性。")]),t._v(" "),s("div",{staticClass:"language-js line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("let")]),t._v(" bs "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("BScroll")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("'.wrapper'")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  eventPassthrough"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("'vertical'")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 保持纵向的原生浏览器滚动")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br")])])])},[],!1,null,null,null);e.default=a.exports}}]);